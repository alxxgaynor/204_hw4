---
title: "Social Cost of Carbon"
author: "Alex Gaynor & Brendon McGovern"
subtitle: ESM 204 - Assignment 4
output:
  # pdf_document: default
  # html_document: default
--- 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE,
                      results = FALSE)

# Setup:

rm(list=ls())

options(scipen=999) # Gives normal numbers, not scientific ones.

gc() # Cleans ram.

# Packages:

packages=c("dplyr",
           "tidyr",
           "stringr",  
           "ggplot2",
           "stargazer",
           "cowplot",
           "janitor",
           "kableExtra") 

# Fancy way to load packages (if its installed, run it, otherwise install it):

lapply(1:length(packages), 
       function(x)
         ifelse((require(packages[x],
                         character.only=TRUE)==FALSE),
                install.packages(packages[x]),
                require(packages[x],
                        character.only=TRUE)))
         
# Set directory (sets the directory where the script is saved to avoid complicated directory paths):

setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

getwd()
```

```{r}
# Load data (useful if letters are in the data to not let R do funny stuff):

damages_data <- read.csv("damages.csv", 
                            stringsAsFactors = F)

warming_import <- read.csv("warming.csv", 
                            stringsAsFactors = F)

warming_data <- warming_import %>%
  clean_names %>% 
  rename("base" ="warming_baseline", 
         "pulse" = "warming_pulse")

# Plot data:
quad_line <- function(x){
  y <- I(20000000000000*x^2) - I(3000000000000*x)
  return(y)
}

fit2<-lm(damages~poly(warming,2,raw=TRUE), 
                       data=damages_data)

quadratic = fit2$coefficient[3]*damages_data$warming^2 + fit2$coefficient[2]*damages_data$warming + fit2$coefficient[1]


dollars_per_damages_plot <- ggplot(data=damages_data, 
                 aes(y=damages, x=warming)) +
  geom_point(aes(x=warming)) +
  theme_cowplot(16) +
  stat_smooth(aes(y = damages),
              method = "lm",
              formula = y ~ I(20000000000000*x^2) - I(3000000000000*x),
              size = 2,
              color = "orange2")
dollars_per_damages_plot
  
plot_2_1 <- ggplot(data=warming_data, 
                 aes(y=quad_line(base), x=year)) +
  theme_cowplot(16) +
    stat_smooth(aes(y=quad_line(base)),
                color = "orange2",
                alpha = 0.8)
plot_2_1

plot_2_2 <- ggplot(data=warming_data, 
                 aes(y=quad_line(pulse), x=year)) +
  theme_cowplot(16) +
    stat_smooth(aes(y=quad_line(pulse)),
                color = "orange2",
                alpha = 0.8)
plot_2_2

# Estimate linear model (model has an implied intercept):

plot_2_3 <- ggplot(data=warming_data, 
                 aes(y=quad_line(pulse), x=year)) +
  theme_cowplot(16) +
  stat_smooth(aes(y=quad_line(pulse) - quad_line(base)),
                color = "orange2",
                alpha = 0.01) +
  scale_y_continuous(labels = function(x) format(x, scientific = TRUE))
plot_2_3

plot_2_4 <- ggplot(data=warming_data, 
                 aes(x=year)) +
  theme_cowplot(16) +
  stat_smooth(aes(y=(quad_line(pulse) - quad_line(base))/35000000000,
                color = "orange2"))
plot_2_4


```

plot_1 <- ggplot(data=warming, 
                 aes(y=base)) +
  geom_line(aes(x=year)) +
  theme_cowplot(16) +
  (quad_line(damages$warming))

```{r}
#making a damage function--do it with stored intercepts later
damage_function <- function(x){
  damage <- -3018856250104*x + 19589020155100*x^2
  return(damage)
}
#creating new columns
warming_scenarios <- warming_data %>% 
  mutate(damage_no_pulse = damage_function(base)) %>% 
  mutate(damage_with_pulse = damage_function(pulse)) %>% 
  mutate(pulse_damages = damage_with_pulse - damage_no_pulse) %>% 
  mutate(pulse_damages_per_ton = pulse_damages/35000000000) %>% 
  mutate(damages_no_pulse_higher = damage_function(base*1.5)) %>%
  mutate(base_b = base)
warming_scenarios$base_b[31:80] <- 1.29

damage_no_pulse_graph <- ggplot(data = warming_scenarios, aes(x = year, y = damage_no_pulse)) + geom_point()
damage_no_pulse_graph
damage_with_pulse_graph <- ggplot(data = warming_scenarios, aes(x = year, y = damage_with_pulse)) + geom_point()
damage_with_pulse_graph
pulse_damages_graph <- ggplot(data = warming_scenarios, aes(x = year, y = pulse_damages)) + geom_point() +
  scale_y_continuous(labels = function(x) format(x, scientific = TRUE))
pulse_damages_graph
pulse_damages_per_ton_graph <- ggplot(data = warming_scenarios, aes(x = year, y = pulse_damages_per_ton)) + geom_point()
pulse_damages_per_ton_graph
```

##3.In order to determine the future of CO2, we built a model based on the CO2 emissions over the 80 years. We then extended the 

```{r}
#making a damage function--do it with stored intercepts later
scc_function <- function(x){
  scc_n <- warming_scenarios$pulse_damages_per_ton /
    I((1 + x)^(warming_scenarios$x-1))
  scc <- sum(scc_n)
  return(scc)
}


fit3<-lm(pulse_damages_per_ton~poly(x,2,raw=TRUE), 
                       data=warming_scenarios)

scc_function_1 <- function(x,q){
  dmg_per_ton <- I(fit3$coefficient[3]*q^2) + I(fit3$coefficient[2]*q) + fit3$coefficient[1]
  scc_per_year <- dmg_per_ton /
    I((1 + x)^(q))
  scc <- sum(scc_per_year)
  return(scc)
}


scc_function_2 <- function(x,k){
  dmg_per_ton <- I(fit3$coefficient[3]*k^2) + I(fit3$coefficient[2]*k) + fit3$coefficient[1]
  scc_per_year <- dmg_per_ton /
    I((1 + x)^k)
  scc <- sum(scc_per_year)
  return(scc)
}

scc_function_3 <- function(x){
  k <- (0:10000)
  dmg_per_ton <- I(fit3$coefficient[3]*k^2) + I(fit3$coefficient[2]*k) + fit3$coefficient[1]
  scc_per_year <- dmg_per_ton /
    I((1 + x)^k)
  scc <- sum(scc_per_year)
  return(scc)
}

scc_tibble <- tibble(x = c(0.01,
                    0.02,
                    0.03,
                    0.04,
                    0.05,
                    0.06,
                    0.07),
                    y = c(369.8745,
                          126.2623,
                          64.10156,
                          39.59037,
                          27.36961,
                          20.34711,
                          15.90986))
  round(digits = 2)


scc_price_per_discount_rate <- ggplot(data = scc_tibble, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(se = FALSE, color = "orange2")
scc_price_per_discount_rate

#4
scc_function_3(0.021) # P* 116.4574



```
```{r}

# For Question 5...changes degrees warming from 
#warming_scenarios <- warming_data %>%
  #mutate(base_b = base)
#warming_scenarios$base_b[31:80] <- 1.29

```

```{r}
#making a damage function--do it with stored intercepts later

# get present values from each policy and then multiply it by the % chance that it occurs.

# Policy A

# baseline (probability 0.5)
a_baseline_function <- function(x){
  a_baseline_n <- warming_scenarios$damage_no_pulse /
    I((1 + x)^(warming_scenarios$x))
  npv_policy_a <- sum(a_baseline_n)
  return(npv_policy_a)
}
# 1.5 times baseline (probability 0.5)
a_higher_baseline_function <- function(x){
  a_higher_baseline_n <- warming_scenarios$damages_no_pulse_higher /
    I((1 + x)^(warming_scenarios$x))
  npv_policy_a_higher <- sum(a_higher_baseline_n)
  return(npv_policy_a_higher)
}

a_baseline_function(0.02)*0.5
a_higher_baseline_function(0.02)*0.5

policy_a <- a_baseline_function(0.02)*0.5 + a_higher_baseline_function(0.02)*0.5
policy_a

# Policy B

#added new column to run the damage function through new base_b column which has (1.29 degree warming damages from 2051-2080)
policy_b_scenarios <- warming_scenarios %>%
  mutate(policy_b_damage_np = damage_function(base_b))

b_baseline_function <- function(x){
  b_baseline_n <- policy_b_scenarios$policy_b_damage_np/
    I((1 + x)^(policy_b_scenarios$x))
  npv_policy_b <- sum(b_baseline_n)
  return(npv_policy_b)
}

# Expected PV of damages up to 2100 under Policy B:
b_baseline_function(0.02)

#policy A = $2,931,794,400,293,097
#policy B = $709,823,683,886,657

```



