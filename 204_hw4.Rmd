---
title: "Social Cost of Carbon"
author: "Alex Gaynor & Brendon McGovern"
subtitle: ESM 204 - Assignment 4
output:
  # pdf_document: default
  # html_document: default
--- 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE,
                      results = FALSE)

# Setup:

rm(list=ls())

options(scipen=999) # Gives normal numbers, not scientific ones.

gc() # Cleans ram.

# Packages:

packages=c("dplyr",
           "tidyr",
           "stringr",  
           "ggplot2",
           "stargazer",
           "cowplot",
           "janitor",
           "kableExtra") 

# Fancy way to load packages (if its installed, run it, otherwise install it):

lapply(1:length(packages), 
       function(x)
         ifelse((require(packages[x],
                         character.only=TRUE)==FALSE),
                install.packages(packages[x]),
                require(packages[x],
                        character.only=TRUE)))
         
# Set directory (sets the directory where the script is saved to avoid complicated directory paths):

setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

getwd()
```

```{r}
# Load data (useful if letters are in the data to not let R do funny stuff):

damages_data <- read.csv("damages.csv", 
                            stringsAsFactors = F)

warming_import <- read.csv("warming.csv", 
                            stringsAsFactors = F)

warming_data <- warming_import %>%
  clean_names %>% 
  rename("base" ="warming_baseline", 
         "pulse" = "warming_pulse")

# Plot data:
quad_line <- function(x){
  y <- I(20000000000000*x^2) - I(3000000000000*x)
  return(y)
}

fit2<-lm(damages~poly(warming,2,raw=TRUE), 
                       data=damages_data)

quadratic = fit2$coefficient[3]*damages_data$warming^2 + fit2$coefficient[2]*damages_data$warming + fit2$coefficient[1]


dollars_per_damages_plot <- ggplot(data=damages_data, 
                 aes(y=damages, x=warming)) +
  geom_point(aes(x=warming)) +
  theme_cowplot(16) +
  stat_smooth(aes(y = damages),
              method = "lm",
              formula = y ~ I(20000000000000*x^2) - I(3000000000000*x),
              size = 2,
              color = "orange2")
dollars_per_damages_plot
  
plot_2_1 <- ggplot(data=warming_data, 
                 aes(y=quad_line(base), x=year)) +
  theme_cowplot(16) +
    stat_smooth(aes(y=quad_line(base)),
                color = "orange2",
                alpha = 0.8)
plot_2_1

plot_2_2 <- ggplot(data=warming_data, 
                 aes(y=quad_line(pulse), x=year)) +
  theme_cowplot(16) +
    stat_smooth(aes(y=quad_line(pulse)),
                color = "orange2",
                alpha = 0.8)
plot_2_2

# Estimate linear model (model has an implied intercept):

plot_2_3 <- ggplot(data=warming_data, 
                 aes(y=quad_line(pulse), x=year)) +
  theme_cowplot(16) +
  stat_smooth(aes(y=quad_line(pulse) - quad_line(base)),
                color = "orange2",
                alpha = 0.01) +
  scale_y_continuous(labels = function(x) format(x, scientific = TRUE))
plot_2_3

plot_2_4 <- ggplot(data=warming_data, 
                 aes(x=year)) +
  theme_cowplot(16) +
  stat_smooth(aes(y=(quad_line(pulse) - quad_line(base))/35000000000,
                color = "orange2"))
plot_2_4


```

plot_1 <- ggplot(data=warming, 
                 aes(y=base)) +
  geom_line(aes(x=year)) +
  theme_cowplot(16) +
  (quad_line(damages$warming))

```{r}
#making a damage function--do it with stored intercepts later
damage_function <- function(x){
  damage <- -3018856250104*x + 19589020155100*x^2
  return(damage)
}
#creating new columns
warming_scenarios <- warming_data %>% 
  mutate(damage_no_pulse = damage_function(base)) %>% 
  mutate(damage_with_pulse = damage_function(pulse)) %>% 
  mutate(pulse_damages = damage_with_pulse - damage_no_pulse) %>% 
  mutate(pulse_damages_per_ton = pulse_damages/35000000000)
damage_no_pulse_graph <- ggplot(data = warming_scenarios, aes(x = year, y = damage_no_pulse)) + geom_point()
damage_no_pulse_graph
damage_with_pulse_graph <- ggplot(data = warming_scenarios, aes(x = year, y = damage_with_pulse)) + geom_point()
damage_with_pulse_graph
pulse_damages_graph <- ggplot(data = warming_scenarios, aes(x = year, y = pulse_damages)) + geom_point() +
  scale_y_continuous(labels = function(x) format(x, scientific = TRUE))
pulse_damages_graph
pulse_damages_per_ton_graph <- ggplot(data = warming_scenarios, aes(x = year, y = pulse_damages_per_ton)) + geom_point()
pulse_damages_per_ton_graph
```

```{r}
#making a damage function--do it with stored intercepts later
scc_function <- function(x){
  scc_n <- warming_scenarios$pulse_damages_per_ton /
    I((1 + x)^(warming_scenarios$x-1))
  scc <- sum(scc_n)
  return(scc)
}


fit3<-lm(pulse_damages_per_ton~poly(x,2,raw=TRUE), 
                       data=warming_scenarios)

scc_function_1 <- function(x,q){
  dmg_per_ton <- I(fit3$coefficient[3]*q^2) + I(fit3$coefficient[2]*q) + fit3$coefficient[1]
  scc_per_year <- dmg_per_ton /
    I((1 + x)^(q))
  scc <- sum(scc_per_year)
  return(scc)
}


scc_function_2 <- function(x,k){
  dmg_per_ton <- I(fit3$coefficient[3]*k^2) + I(fit3$coefficient[2]*k) + fit3$coefficient[1]
  scc_per_year <- dmg_per_ton /
    I((1 + x)^k)
  scc <- sum(scc_per_year)
  return(scc)
}

scc_function_3 <- function(x){
  k <- (0:10000)
  dmg_per_ton <- I(fit3$coefficient[3]*k^2) + I(fit3$coefficient[2]*k) + fit3$coefficient[1]
  scc_per_year <- dmg_per_ton /
    I((1 + x)^k)
  scc <- sum(scc_per_year)
  return(scc)
}


scc_function_3(0.03) 

scc_tibble <- tibble(x = c(0.01,
                    0.02,
                    0.03,
                    0.04,
                    0.05,
                    0.06,
                    0.07),
                    y = c(369.8745,
                          126.2623,
                          64.10156,
                          39.59037,
                          27.36961,
                          20.34711,
                          15.90986))
  round(digits = 2)


scc_price_per_discount_rate <- ggplot(data = scc_tibble, aes(x = x, y = y)) + 
  geom_point() + 
  stat_smooth(se = FALSE, color = "orange2")
scc_price_per_discount_rate

```

`r 
