---
title: "Social Cost of Carbon"
author: "Alex Gaynor & Brendon McGovern"
subtitle: ESM 204 - Assignment 4
output:
  # pdf_document: default
  # html_document: default
--- 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE,
                      results = FALSE)

# Setup:

rm(list=ls())

options(scipen=999) # Gives normal numbers, not scientific ones.

gc() # Cleans ram.

# Packages:

packages=c("dplyr",
           "tidyr",
           "stringr",  
           "ggplot2",
           "stargazer",
           "cowplot",
           "janitor",
           "kableExtra") 

# Fancy way to load packages (if its installed, run it, otherwise install it):

lapply(1:length(packages), 
       function(x)
         ifelse((require(packages[x],
                         character.only=TRUE)==FALSE),
                install.packages(packages[x]),
                require(packages[x],
                        character.only=TRUE)))
         
# Set directory (sets the directory where the script is saved to avoid complicated directory paths):

setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

getwd()
```

```{r}
# Load data (useful if letters are in the data to not let R do funny stuff):

damages_data <- read.csv("damages.csv", 
                            stringsAsFactors = F)

warming_import <- read.csv("warming.csv", 
                            stringsAsFactors = F)

warming_data <- warming_import %>%
  clean_names %>% 
  rename("base" ="warming_baseline", 
         "pulse" = "warming_pulse")

# Plot data:
quad_line <- function(x){
  y <- I(20000000000000*x^2) - I(3000000000000*x)
  return(y)
}

fit2<-lm(damages~poly(warming,2,raw=TRUE), 
                       data=damages_data)

quadratic = fit2$coefficient[3]*damages_data$warming^2 + fit2$coefficient[2]*damages_data$warming + fit2$coefficient[1]


dollars_per_damages_plot <- ggplot(data=damages_data, 
                 aes(y=damages, x=warming)) +
  geom_point(aes(x=warming)) +
  theme_cowplot(16) +
  stat_smooth(aes(y = damages),
              method = "lm",
              formula = y ~ I(20000000000000*x^2) - I(3000000000000*x),
              size = 2,
              color = "orange2")
dollars_per_damages_plot
  
plot_2_1 <- ggplot(data=warming_data, 
                 aes(y=quad_line(base), x=year)) +
  theme_cowplot(16) +
    stat_smooth(aes(y=quad_line(base)),
                color = "orange2",
                alpha = 0.8)
plot_2_1

plot_2_2 <- ggplot(data=warming_data, 
                 aes(y=quad_line(pulse), x=year)) +
  theme_cowplot(16) +
    stat_smooth(aes(y=quad_line(pulse)),
                color = "orange2",
                alpha = 0.8)
plot_2_2

# Estimate linear model (model has an implied intercept):

plot_2_3 <- ggplot(data=warming_data, 
                 aes(y=quad_line(pulse), x=year)) +
  theme_cowplot(16) +
  stat_smooth(aes(y=quad_line(pulse) - quad_line(base)),
                color = "orange2",
                alpha = 0.01) +
  scale_y_continuous(labels = function(x) format(x, scientific = TRUE))
plot_2_3

plot_2_4 <- ggplot(data=warming_data, 
                 aes(x=year)) +
  theme_cowplot(16) +
  stat_smooth(aes(y=(quad_line(pulse) - quad_line(base))/35000000000,
                color = "orange2"))
plot_2_4


```

plot_1 <- ggplot(data=warming, 
                 aes(y=base)) +
  geom_line(aes(x=year)) +
  theme_cowplot(16) +
  (quad_line(damages$warming))

```{r}
#making a damage function--do it with stored intercepts later
damage_function <- function(x){
  damage <- -3018856250104*x + 19589020155100*x^2
  return(damage)
}
#creating new columns
warming_scenarios <- warming_data %>% 
  mutate(damage_no_pulse = damage_function(base)) %>% 
  mutate(damage_with_pulse = damage_function(pulse)) %>% 
  mutate(pulse_damages = damage_with_pulse - damage_no_pulse) %>% 
  mutate(pulse_damages_per_ton = pulse_damages/35000000000) %>% 
  mutate(damages_no_pulse_higher = damage_function(base*1.5)) %>%
  mutate(base_b = base)
warming_scenarios$base_b[31:80] <- 1.29

damage_no_pulse_graph <- ggplot(data = warming_scenarios, aes(x = year, y = damage_no_pulse)) + geom_point()
damage_no_pulse_graph
damage_with_pulse_graph <- ggplot(data = warming_scenarios, aes(x = year, y = damage_with_pulse)) + geom_point()
damage_with_pulse_graph
pulse_damages_graph <- ggplot(data = warming_scenarios, aes(x = year, y = pulse_damages)) + geom_point() +
  scale_y_continuous(labels = function(x) format(x, scientific = TRUE))
pulse_damages_graph
pulse_damages_per_ton_graph <- ggplot(data = warming_scenarios, aes(x = year, y = pulse_damages_per_ton)) + geom_point()
pulse_damages_per_ton_graph
```

##3.In order to determine the future of CO2, we built a model based on the CO2 emissions over the 80 years. We then extended the 

```{r}
#making a damage function--do it with stored intercepts later
scc_function <- function(x){
  scc_n <- warming_scenarios$pulse_damages_per_ton /
    I((1 + x)^(warming_scenarios$x-1))
  scc <- sum(scc_n)
  return(scc)
}


fit3<-lm(pulse_damages_per_ton~poly(x,2,raw=TRUE), 
                       data=warming_scenarios)

scc_function_1 <- function(x,q){
  dmg_per_ton <- I(fit3$coefficient[3]*q^2) + I(fit3$coefficient[2]*q) + fit3$coefficient[1]
  scc_per_year <- dmg_per_ton /
    I((1 + x)^(q))
  scc <- sum(scc_per_year)
  return(scc)
}


scc_function_2 <- function(x,k){
  dmg_per_ton <- I(fit3$coefficient[3]*k^2) + I(fit3$coefficient[2]*k) + fit3$coefficient[1]
  scc_per_year <- dmg_per_ton /
    I((1 + x)^k)
  scc <- sum(scc_per_year)
  return(scc)
}

scc_function_3 <- function(x){
  k <- (0:10000)
  dmg_per_ton <- I(fit3$coefficient[3]*k^2) + I(fit3$coefficient[2]*k) + fit3$coefficient[1]
  scc_per_year <- dmg_per_ton /
    I((1 + x)^k)
  scc <- sum(scc_per_year)
  return(scc)
}

scc_function_3(0.02)

scc_tibble <- tibble(x = c(0.01,
                    0.02,
                    0.03,
                    0.04,
                    0.05,
                    0.06,
                    0.07),
                    y = c(369.8745,
                          126.2623,
                          64.10156,
                          39.59037,
                          27.36961,
                          20.34711,
                          15.90986))
  round(digits = 2)


scc_price_per_discount_rate <- ggplot(data = scc_tibble, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(se = FALSE, color = "orange2")
scc_price_per_discount_rate

#4

scc_function_3(0.021)
scc_function_3(0.021) # P* 116.4574



```
```{r}

# For Question 5...changes degrees warming from 
#warming_scenarios <- warming_data %>%
  #mutate(base_b = base)
#warming_scenarios$base_b[31:80] <- 1.29

```

```{r}

# get present values from each policy and then multiply it by the % chance that it occurs.

# Policy A

# baseline (probability 0.5)
a_baseline_function <- function(x){
  a_baseline_n <- warming_scenarios$damage_no_pulse /
    I((1 + x)^(warming_scenarios$x))
  npv_policy_a <- sum(a_baseline_n)
  return(npv_policy_a)
}
# 1.5 times baseline (probability 0.5)
a_higher_baseline_function <- function(x){
  a_higher_baseline_n <- warming_scenarios$damages_no_pulse_higher /
    I((1 + x)^(warming_scenarios$x))
  npv_policy_a_higher <- sum(a_higher_baseline_n)
  return(npv_policy_a_higher)
}

a_baseline_function(0.02)*0.5
a_higher_baseline_function(0.02)*0.5

policy_a <- a_baseline_function(0.02)*0.5 + a_higher_baseline_function(0.02)*0.5
policy_a

# Policy B

#added new column to run the damage function through new base_b column which has (1.29 degree warming damages from 2051-2080)
policy_b_scenarios <- warming_scenarios %>%
  mutate(policy_b_damage_np = damage_function(base_b))

b_baseline_function <- function(x){
  b_baseline_n <- policy_b_scenarios$policy_b_damage_np/
    I((1 + x)^(policy_b_scenarios$x))
  npv_policy_b <- sum(b_baseline_n)
  return(npv_policy_b)
}

# Expected PV of damages up to 2100 under Policy B:
b_baseline_function(0.02)

#policy A = $2,931,794,400,293,097
#policy B = $709,823,683,886,657

#Policy A - Policy B
2931794400293097 - 709823683886657
#Policy A - Policy B = $2,221,970,716,406,440. Under a risk neutral society you could subtract Policy A - Policy B and as long as the cost of implementing Policy B does not exceed the difference from subtracting the two policies then Policy B should be pursued and implemented. Policy B suggests that society implements full scale renewable technology and is no longer adding CO2 that warms the atmosphere by 2050. So, if society is risk averse, they would be willing to pay more for Policy B because the utility from the certainty of Policy B is higher than the expected utility from Policy A. 

policy_a
b_baseline_function(.02)

```


### 1) Estimate a quadratic damage function relating the dollar value of damages to the change in global mean temperature

## To determine the damage function, we plotted damage at each temperature in the data and then calculated the model that best fits.

```{r}
dollars_per_damages_plot
```

### 2) Estimate damage function to predict damages in each year under the baseline climate and the pulse scenario

## We used warming data to map on the damages data we previously found.

## a) Baseline

```{r}
baseline_damages_graph
```

## a) Pulse

```{r}
pulse_damages_graph
```

## a) Difference between baseline and pulse

```{r}
difference_damages_graph
```

## a) Difference per ton

```{r}
difference_per_ton_graph
```

### 3) Calculate and make a plot of the SCC (y-axis) against the discount rate (x-axis) for a reasonable range of discount rates.

## We divided damage per ton of the initial pulse by the total amount of tons emitted by that pulse to get ther per ton damage function. In order to predict the total future of the damage we modeled the curve of the per ton damage and then calculated it from time 0 to time 10,000 although it did not noticibly change after 1,000 years. With this equation in hand, you can input a discount rate such as 0.2 and get the SCC based on the damage into the future discounted at that rate.

```{r}
scc_price_per_discount_rate
```

